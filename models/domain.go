// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2020 SAP SE
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Domain A representation of a domain
//
// swagger:model domain
type Domain struct {

	// The administrative state of the resource, which is up (true) or down (false). Default is true.
	AdminStateUp *bool `json:"admin_state_up,omitempty" db:"admin_state_up,omitempty"`

	// aliases
	Aliases []string `json:"aliases" db:"aliases"`

	// If not empty, the backend created a CNAME target to be used for the FQDN.
	// Example: example.org.production.gtm.com
	// Read Only: true
	// Format: hostname
	CnameTarget *strfmt.Hostname `json:"cname_target,omitempty" db:"cname_target,omitempty"`

	// The UTC date and timestamp when the resource was created.
	// Example: 2020-05-11T17:21:34
	// Read Only: true
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty" db:"created_at,omitempty"`

	// Desired Fully-Qualified Host Name.
	// Example: example.org
	// Max Length: 512
	// Format: hostname
	Fqdn *strfmt.Hostname `json:"fqdn,omitempty" db:"fqdn,omitempty"`

	// The id of the resource.
	// Read Only: true
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty" db:"id,omitempty"`

	// Load balancing method to use for the references pools.
	// Enum: [WEIGHTED ROUND_ROBIN GEOGRAPHIC AVAILABILITY]
	Mode *string `json:"mode,omitempty" db:"mode,omitempty"`

	// Human-readable name of the resource.
	Name *string `json:"name,omitempty" db:"name,omitempty"`

	// pools
	Pools []strfmt.UUID `json:"pools" db:"pools"`

	// The ID of the project owning this resource.
	// Example: fa84c217f361441986a220edf9b1e337
	// Max Length: 32
	// Min Length: 32
	ProjectID *string `json:"project_id,omitempty" db:"project_id,omitempty"`

	// Supported provider drivers
	// Example: akamai
	// Enum: [akamai f5]
	Provider *string `json:"provider,omitempty" db:"provider,omitempty"`

	// provisioning status
	// Read Only: true
	// Enum: [PENDING_CREATE PENDING_UPDATE PENDING_DELETE ACTIVE ERROR]
	ProvisioningStatus string `json:"provisioning_status,omitempty" db:"provisioning_status,omitempty"`

	// DNS Record type to use.
	// Enum: [A AAAA CNAME MX]
	RecordType *string `json:"record_type,omitempty" db:"record_type,omitempty"`

	// status
	// Read Only: true
	// Enum: [ONLINE DOWN]
	Status string `json:"status,omitempty" db:"status,omitempty"`

	// The UTC date and timestamp when the resource was created.
	// Example: 2020-09-09T14:52:15
	// Read Only: true
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty" db:"updated_at,omitempty"`
}

// Validate validates this domain
func (m *Domain) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCnameTarget(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFqdn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePools(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecordType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Domain) validateCnameTarget(formats strfmt.Registry) error {
	if swag.IsZero(m.CnameTarget) { // not required
		return nil
	}

	if err := validate.FormatOf("cname_target", "body", "hostname", m.CnameTarget.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Domain) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Domain) validateFqdn(formats strfmt.Registry) error {
	if swag.IsZero(m.Fqdn) { // not required
		return nil
	}

	if err := validate.MaxLength("fqdn", "body", m.Fqdn.String(), 512); err != nil {
		return err
	}

	if err := validate.FormatOf("fqdn", "body", "hostname", m.Fqdn.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Domain) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

var domainTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["WEIGHTED","ROUND_ROBIN","GEOGRAPHIC","AVAILABILITY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		domainTypeModePropEnum = append(domainTypeModePropEnum, v)
	}
}

const (

	// DomainModeWEIGHTED captures enum value "WEIGHTED"
	DomainModeWEIGHTED string = "WEIGHTED"

	// DomainModeROUNDROBIN captures enum value "ROUND_ROBIN"
	DomainModeROUNDROBIN string = "ROUND_ROBIN"

	// DomainModeGEOGRAPHIC captures enum value "GEOGRAPHIC"
	DomainModeGEOGRAPHIC string = "GEOGRAPHIC"

	// DomainModeAVAILABILITY captures enum value "AVAILABILITY"
	DomainModeAVAILABILITY string = "AVAILABILITY"
)

// prop value enum
func (m *Domain) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, domainTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Domain) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("mode", "body", *m.Mode); err != nil {
		return err
	}

	return nil
}

func (m *Domain) validatePools(formats strfmt.Registry) error {
	if swag.IsZero(m.Pools) { // not required
		return nil
	}

	for i := 0; i < len(m.Pools); i++ {

		if err := validate.FormatOf("pools"+"."+strconv.Itoa(i), "body", "uuid", m.Pools[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *Domain) validateProjectID(formats strfmt.Registry) error {
	if swag.IsZero(m.ProjectID) { // not required
		return nil
	}

	if err := validate.MinLength("project_id", "body", *m.ProjectID, 32); err != nil {
		return err
	}

	if err := validate.MaxLength("project_id", "body", *m.ProjectID, 32); err != nil {
		return err
	}

	return nil
}

var domainTypeProviderPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["akamai","f5"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		domainTypeProviderPropEnum = append(domainTypeProviderPropEnum, v)
	}
}

const (

	// DomainProviderAkamai captures enum value "akamai"
	DomainProviderAkamai string = "akamai"

	// DomainProviderF5 captures enum value "f5"
	DomainProviderF5 string = "f5"
)

// prop value enum
func (m *Domain) validateProviderEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, domainTypeProviderPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Domain) validateProvider(formats strfmt.Registry) error {
	if swag.IsZero(m.Provider) { // not required
		return nil
	}

	// value enum
	if err := m.validateProviderEnum("provider", "body", *m.Provider); err != nil {
		return err
	}

	return nil
}

var domainTypeProvisioningStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PENDING_CREATE","PENDING_UPDATE","PENDING_DELETE","ACTIVE","ERROR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		domainTypeProvisioningStatusPropEnum = append(domainTypeProvisioningStatusPropEnum, v)
	}
}

const (

	// DomainProvisioningStatusPENDINGCREATE captures enum value "PENDING_CREATE"
	DomainProvisioningStatusPENDINGCREATE string = "PENDING_CREATE"

	// DomainProvisioningStatusPENDINGUPDATE captures enum value "PENDING_UPDATE"
	DomainProvisioningStatusPENDINGUPDATE string = "PENDING_UPDATE"

	// DomainProvisioningStatusPENDINGDELETE captures enum value "PENDING_DELETE"
	DomainProvisioningStatusPENDINGDELETE string = "PENDING_DELETE"

	// DomainProvisioningStatusACTIVE captures enum value "ACTIVE"
	DomainProvisioningStatusACTIVE string = "ACTIVE"

	// DomainProvisioningStatusERROR captures enum value "ERROR"
	DomainProvisioningStatusERROR string = "ERROR"
)

// prop value enum
func (m *Domain) validateProvisioningStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, domainTypeProvisioningStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Domain) validateProvisioningStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateProvisioningStatusEnum("provisioning_status", "body", m.ProvisioningStatus); err != nil {
		return err
	}

	return nil
}

var domainTypeRecordTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["A","AAAA","CNAME","MX"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		domainTypeRecordTypePropEnum = append(domainTypeRecordTypePropEnum, v)
	}
}

const (

	// DomainRecordTypeA captures enum value "A"
	DomainRecordTypeA string = "A"

	// DomainRecordTypeAAAA captures enum value "AAAA"
	DomainRecordTypeAAAA string = "AAAA"

	// DomainRecordTypeCNAME captures enum value "CNAME"
	DomainRecordTypeCNAME string = "CNAME"

	// DomainRecordTypeMX captures enum value "MX"
	DomainRecordTypeMX string = "MX"
)

// prop value enum
func (m *Domain) validateRecordTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, domainTypeRecordTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Domain) validateRecordType(formats strfmt.Registry) error {
	if swag.IsZero(m.RecordType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecordTypeEnum("record_type", "body", *m.RecordType); err != nil {
		return err
	}

	return nil
}

var domainTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ONLINE","DOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		domainTypeStatusPropEnum = append(domainTypeStatusPropEnum, v)
	}
}

const (

	// DomainStatusONLINE captures enum value "ONLINE"
	DomainStatusONLINE string = "ONLINE"

	// DomainStatusDOWN captures enum value "DOWN"
	DomainStatusDOWN string = "DOWN"
)

// prop value enum
func (m *Domain) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, domainTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Domain) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Domain) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this domain based on the context it is used
func (m *Domain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCnameTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Domain) contextValidateCnameTarget(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cname_target", "body", m.CnameTarget); err != nil {
		return err
	}

	return nil
}

func (m *Domain) contextValidateCreatedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "created_at", "body", strfmt.DateTime(m.CreatedAt)); err != nil {
		return err
	}

	return nil
}

func (m *Domain) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", strfmt.UUID(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Domain) contextValidateProvisioningStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "provisioning_status", "body", string(m.ProvisioningStatus)); err != nil {
		return err
	}

	return nil
}

func (m *Domain) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *Domain) contextValidateUpdatedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updated_at", "body", strfmt.DateTime(m.UpdatedAt)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Domain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Domain) UnmarshalBinary(b []byte) error {
	var res Domain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
